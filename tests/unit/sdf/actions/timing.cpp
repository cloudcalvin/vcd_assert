// #include "parse/test/parse.hpp"

#include <sdf/actions/timing.hpp>
// #include "sdf/grammar/header.hpp"
// // #include "sdf/grammar/timing.hpp"

// // #include "../types/timing.hpp"

// #include <catch2/catch.hpp>
// #include <fmt/format.h>

// using namespace SDF;
// using namespace SDF::Test;
// using Parse::Test::require_parse;


/* TODO 
constexpr char test_scalar_port_str[] = "DIN";
constexpr char test_vector_port_str[] = "DIN[4:0]";

struct ScalarNodeAction : multi_dispatch<
struct TimingCheckCondAction : multi_dispatch<
struct PortSpecAction : single_dispatch<
struct PortCheckAction : single_dispatch<
struct HoldPortStorage  {
struct HoldPortTupleAction : single_dispatch<
struct HoldPortAction : single_dispatch<
struct HoldTimingCheckAction : multi_dispatch<
struct TimingCheckAction : single_dispatch<
struct TimingCheckArrayAction : single_dispatch<
*/

// TEST_CASE("SDF.Actions.Node", "[SDF][Actions][Node]")
// {
//   SECTION(fmt::format("ScalarNode {}", port_1_str)){

//     Node test{};
//     Node wanted{NodeType::port, std::string{port_1_str}};
//     // require_parse<Grammar::scalar_node, Actions::ScalarNodeAction>(test_hold_str_,test);
//     // REQUIRE(test == wanted);
//     REQUIRE(1);
//   }

//   // SECTION(fmt::format("VecrorNode {}", port_1_str)){ //unimplemented
//   //   Node test{};
//   //   Node wanted{test_hold_str};
//   //   require_parse<Grammar::vector_node, Actions::VectorNode>(test_vector_port_str, test);
//   //   REQUIRE(test == wanted);
//   // }
  
// }


